# Преобразования функциональных формул

## Замена переменной (альфа-эквивалентность)

```haskell

\x -> ... x ...
\y -> ... y ...

```

При условии, что заменяются вхождения только этой переменной
(но не другой с таким же именем) и новая переменная ещё не встречается в теле.

## Подстановка (бета-редукция)

```haskell

(\x -> expr[x]) a = expr[x := a] -- псевдокод

[x := a] -- замена всех вхождений переменной `x` на выражение `a`

-- пример
(\x -> x + x) a = a + a

```

## Определение функции с аргументами (специфика Хаскелла)

```haskell

-- от одного аргумента
f  =  \x  ->  expr
f      x   =  expr

-- от нескольких аргументов
f  =  \x  ->  \y  ->  \z  ->  expr
f  =  \x       y       z  ->  expr
f      x       y       z   =  expr

f  =  \x  ->  \y  ->  \z  ->  expr
f      x   =  \y  ->  \z  ->  expr
f      x       y   =  \z  ->  expr
f      x       y       z   =  expr

```

## Применение к одному аргументу (эта-преобразование)

```haskell

-- идея
f == g  <=>  f x == g x

-- эта-редукция
\x -> f x  -->  f
f x = g x  -->  f = g

-- эта-расширение (eta-expansion)
f      -->  \x -> f x
f = g  -->  f x = g x

```

# Простейшие функции

```haskell

id x = x  -- I
id = \x -> x

const x _ = x  -- K
const x = \_ -> x

```

# Функции высших порядков (комбинаторы, функционалы)

## Аппликация как функция

```haskell

apply f x = f x

-- обозначим символом ($)
($) f x = f x
f $ x = f x

-- применим эта-редукцию
($) f x = f x
($) f   = f

-- но это же определение id!
($) f = f
id  x = x
($) == id

```

## Композиция

```haskell

-- определение
f . g = \x -> f (g x)

-- перенесём x в левую часть
(f . g) x = f (g x)

-- заменим простую аппликацию на ($)

f . g $ x =
f $ g $ x

f . g . h $ x =  -- рекомендуемая форма
f $ g . h $ x =
f . g $ h $ x =
f $ g $ h $ x

```

# Функции нескольких переменных

Оказывается, функции нескольких переменных не нужны,
когда есть сахар для передачи аргументов по очереди.

Но иногда нужны функции от кортежей.

```haskell

f₁(x, y) = x + y

f₂ x  y  = x + y

f₁ /= f₂
f₁  ≈ f₂

    ╭──curry──╮
    │         ▼
f₁(x, y)    f₂ x y
    ▲         │
    ╰─uncurry─╯

curry   f = \ x  y  -> f (x, y)
uncurry f = \(x, y) -> f  x  y

-- пример
fst (x, _) = x
snd (_, y) = y

curry fst = \x y -> fst (x, y)
          = \x y -> x
          = const

uncurry const = \(x, y) -> const x y
              = \(x, y) -> x
              = fst

curry snd = \x y -> snd (x, y)
          = \x y -> y
          = \x -> \y -> y
          = \x -> id
          = const id

uncurry id  = \(x, y) -> id x y
            = \(x, y) -> x y

```
