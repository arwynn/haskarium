# Лень

```haskell

λ> ints = [1..]

λ> take 5 ints
[1,2,3,4,5]

```

## Call-by-need

Каждое выражение не вычисляется там, где написано, а только создаёт _задумку_.
Реально вычисляется только то, что запрошено.

## Pseudo-code

```haskell

data Value a
    = ActualValue a
    | Thunk (e -> Value a) e

ints = [1..]
ints = Thunk enumFrom 1

take 5 ints = Thunk take (5, ints)
            = [1, 2, 3, 4, 5]
ints = 1 : 2 : 3 : 4 : 5
            : Thunk enumFrom (Thunk (+) (5, 1))

```

## Плюсы

+ Компилируется почти любая формула, имеющая смысл в голове программиста,
  без ограничения на порядок вычисления (примеры в других пунктах)

+ Бесконечные и рекурсивные данные

  ```haskell
  natural = [1 ..]
  ones = 1 : ones
  fibs = 1 : 1 : [x + y | (x, y) <- zip fibs (tail fibs)]
  ```

+ Взаимно зависимые вычисления

  ```haskell
  λ> xs = [sum (tail xs), length xs, 42, xs !! 1]
  λ> xs
  [50,4,42,4]
  ```

+ Раннее получение результата

  ```haskell
  λ> fibs
  [1,1,2,3,5,8,13,21,34,55^C,Interrupted.
  ```

+ Экономия памяти

  ```haskell

  -- вычисляем голову и сразу выбрасываем
  [1 .. 10000000000]
  enumFromTo 1 10000000000
  Thunk enumFromTo (1, 10000000000)
  1 : Thunk enumFromTo (2, 10000000000)
  Thunk enumFromTo (2, 10000000000)
  2 : Thunk enumFromTo (3, 10000000000)
  Thunk enumFromTo (3, 10000000000)
  ...

  ```

## Минусы

- Сложно предсказать расход памяти

  Но это редко является проблемой.

- Сложно предсказать порядок вычисления

  Но вы не должны этого хотеть.

- Легко написать неограниченную рекурсию

  ```haskell
  x = x + 1
  ```

## Подводные камни

* Space leak
  Не путать с memory leak!

  ```haskell

  sum [1..1000000]
  = Thunk foldl ((+), 0, [1..1000000])
  = Thunk foldl ((+), 0, [1..1000000])
  = Thunk foldl ((+), Thunk (+) (0, 1), [2..1000000])
  = Thunk foldl ((+), Thunk (+) (Thunk (+) (0, 1), 3), [3..1000000])
  = ... -- задумки только растут, ничего не начнёт вычисляться до самого конца

  ```

  Можно явно принуждать задумки к вычислению в тех местах, где это надо.
  Как это следать, расскажем потом.

  ```haskell

  sum' [1..1000000]
  = Thunk foldl' ((+), 0, [1..1000000])
  = Thunk foldl' ((+), !Thunk (+) (0, 1), [2..1000000])
  = Thunk foldl' ((+), 1, [2..1000000])
  = Thunk foldl' ((+), !Thunk (+) (1, 3), [3..1000000])
  = Thunk foldl' ((+), 4, [3..1000000])
  = ... -- память амортизированно константная

  ```
