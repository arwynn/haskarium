# Тип-сумма

## Определение

```haskell
data ИмяТипа = Конструктор1 с полями | Конструктор2 с полями | ...
```

--------------------------------------------------------------------------------

Примеры:

```haskell
data Bool = False | True
```

Тип `Bool` состоит из символов `False` и `True`.

--------------------------------------------------------------------------------

```haskell
data Species = Ant | Bug | DragonFly | Flea | Fly
```

Значение типа `Species` может быть одним из этих 5 символов.
Никакое другое значение не может принадлежать этому типу.

--------------------------------------------------------------------------------

```haskell
data SearchResult = NotFound | Found Natural
```

Значение типа `SearchResult` может быть или символом `NotFound`
(без дополнительных данных),
или символом `Found` вместе со значением типа `Natural`.

--------------------------------------------------------------------------------

Фактически, каждое из слагаемых типа-суммы — это произведение типов.

--------------------------------------------------------------------------------

```haskell
data JsonValue
    = JsonArray [JsonValue] -- рекурсия!
    | JsonBool Bool
    | JsonNull
    | JsonNumber Decimal
    | JsonObject [(String, JsonValue)] -- рекурсия!
    | JsonString String
```

--------------------------------------------------------------------------------

```haskell
data Suit = Spades | Hearts | Diamonds | Clubs
data Card
    = King Suit
    | Queen Suit
    | Knight Suit
    | Knave Suit
    | MinorCard Suit Int
    | Trump Int
    | Joker
```

--------------------------------------------------------------------------------

## Создание значения

Тут всё просто

```haskell
exampleObject = JsonObject
    [ ("width",  JsonNumber 800)
    , ("height", JsonNumber 600)
    , ("title",  JsonString "Haskarium")
    ]
```

--------------------------------------------------------------------------------

## Чтение через паттерн-матчинг

Можно это сделать двумя способами:
множественными уравнениями функции и специальным оператором `case-of`.

### Много уравнений

Функцию можно задать несколькими уравнениями:

```haskell
localizeRu Ant = "муравей"
localizeRu Bug = "жук"
localizeRu Fly = "муха"
```

В уравнениях можно одновременно паттерн-матчить несколько аргументов

```haskell
localize Ru  Ant = "муравей"
localize Ru  Bug = "жук"
localize Ru  Fly = "муха"
localize Cow _   = "му"
```

--------------------------------------------------------------------------------

Паттерны проверяются в том порядке, в котором написаны в коде.
Срабатывает первый подошедший.

```haskell
localize Cow _   = "му"
localize Cow Ant = "му-му" -- недостижимое уравнение
```

--------------------------------------------------------------------------------

### Оператор `case-of`

```haskell
-- синтаксис
case выражение of
    паттерн1 -> значение1
    паттерн2 -> значение2
    ...
```

```haskell
localize lang species = case lang of
    Cow -> "му"
    Ru  -> case species of
        Ant -> "муравей"
        Bug -> "жук"
        Fly -> "муха"
```

Можно разбирать только одно выражение, зато не только в аргументах,
а в середине любого выражения.

--------------------------------------------------------------------------------

## Аналоги в других языках

(Подход "tagged union")

- `variant` в С++ >= 17 (GCC >= 7) (но не `boost::variant`!)
- Тип-сумма в *ML

  - `enum` в Rust
